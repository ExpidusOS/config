const std = @import("std");

pub fn readSupportedLocales(allocator: std.mem.Allocator) !std.ArrayList([]const u8) {
    const localeArchive = try std.fs.realpathAlloc(allocator, std.os.getenv("LOCALE_ARCHIVE") orelse "/run/current-system/sw/lib/locale/locale-archive");
    defer allocator.free(localeArchive);

    const rootpath = std.fs.path.dirname(std.fs.path.dirname(std.fs.path.dirname(localeArchive)));
    const supportedPath = std.fs.path.join(allocator, &.{ rootpath, "share", "i18n", "SUPPORTED" });
    defer allocator.free(supportedPath);

    const supportedFile = try std.fs.openFileAbsolute(supportedPath, .{});
    defer supportedFile.close();

    const supportedMeta = try supportedFile.metadata();

    const list = std.ArrayList([]const u8).init(allocator);
    errdefer list.deinit();

    while (true) {
        const supported = try supportedFile.reader().readUntilDelimiterAlloc(allocator, '\n', supportedMeta.size());
        defer allocator.free(supported);

        if (!std.mem.startsWith(u8, supported, "SUPPORTED-LOCALES=")) continue;

        const kv = std.mem.splitAny(u8, supported, "=");
        kv.next();

        const value = kv.next();
        const values = std.mem.splitAny(u8, value, " ");
        for (values) |v| try list.append(try allocator.dupe(u8, v));
        break;
    }
    return list;
}

pub fn randomChar(rand: std.rand.Random) u8 {
    const offset: u8 = if (rand.boolean()) 'A' else 'a';
    return rand.uintAtMost(u8, 25) + offset;
}

pub fn randomString(rand: std.rand.Random, buf: []u8) void {
    var i: usize = 0;

    while (i != buf.len) : (i += 1) {
        const ch = randomChar(rand);
        buf[i] = ch;
    }
}

pub fn allocRandomString(rand: std.rand.Random, allocator: std.mem.Allocator, size: usize) ![]const u8 {
    var buf = try allocator.alloc(u8, size);
    errdefer allocator.free(buf);
    randomString(rand, buf);
    return buf;
}

pub fn readFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.openFileAbsolute(path, .{});
    defer file.close();

    const metadata = try file.metadata();
    const buffer = try allocator.alloc(u8, metadata.size());
    errdefer allocator.free(buffer);

    _ = try file.readAll(buffer);
    return buffer;
}

pub fn readJsonFile(comptime T: type, allocator: std.mem.Allocator, path: []const u8) anyerror!std.json.Parsed(T) {
    const buffer = try readFile(allocator, path);
    defer allocator.free(buffer);
    return try std.json.parseFromSlice(T, allocator, buffer, .{
        .allocate = .alloc_always,
    });
}

pub fn writeFile(path: []const u8, value: []const u8) !void {
    const file = std.fs.openFileAbsolute(path, .{
        .mode = .write_only,
    }) catch try std.fs.createFileAbsolute(path, .{});
    defer file.close();
    try file.writeAll(value);
}

pub fn writeJsonFile(path: []const u8, value: anytype) !void {
    const file = try std.fs.openFileAbsolute(path, .{
        .mode = .write_only,
    });
    defer file.close();
    try std.json.stringify(value, .{}, file.writer());
}

pub fn genHosts(allocator: std.mem.Allocator, hostname: []const u8) ![]const u8 {
    return try std.fmt.allocPrint(allocator,
        \\# Generated by ExpidusOS Config
        \\127.0.0.1 localhost
        \\::1 localhost
        \\
        \\127.0.0.1 {0s}
        \\::1 {0s}
    , .{hostname});
}

pub fn bindMount(source: []const u8, dest: []const u8) !void {
    const rc = std.os.linux.mount(source[0..source.len :0], dest[0..dest.len :0], "bind", std.os.linux.MS.BIND, 0);
    switch (std.os.errno(rc)) {
        .SUCCESS => return,
        .ACCES => return error.AccessDenied,
        else => |err| return std.os.unexpectedErrno(err),
    }
}

test "host file generation" {
    const alloc = std.testing.allocator;

    const generated = try genHosts(alloc, "example");
    defer alloc.free(generated);

    try std.testing.expectEqualStrings(
        \\# Generated by ExpidusOS Config
        \\127.0.0.1 localhost
        \\::1 localhost
        \\
        \\127.0.0.1 example
        \\::1 example
    , generated);
}
